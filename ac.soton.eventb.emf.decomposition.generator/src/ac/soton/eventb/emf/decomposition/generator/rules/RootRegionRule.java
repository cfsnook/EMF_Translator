package ac.soton.eventb.emf.decomposition.generator.rules;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.InternalEObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eventb.core.IMachineRoot;
import org.eventb.emf.core.AbstractExtension;
import org.eventb.emf.core.CorePackage;
import org.eventb.emf.core.Project;
import org.eventb.emf.core.machine.Event;
import org.eventb.emf.core.machine.Machine;
import org.eventb.emf.core.machine.MachineFactory;
import org.eventb.emf.core.machine.MachinePackage;
import org.eventb.emf.persistence.EventBEMFUtils;

import ac.soton.emf.translator.TranslationDescriptor;
import ac.soton.emf.translator.configuration.IRule;
import ac.soton.emf.translator.utils.Find;
import ac.soton.eventb.decomposition.AbstractRegion;
import ac.soton.eventb.emf.core.extension.navigator.refiner.AbstractElementRefiner;
import ac.soton.eventb.emf.core.extension.navigator.refiner.ElementRefinerRegistry;
import ac.soton.eventb.emf.decomposition.generator.Make;


public class RootRegionRule extends AbstractRegionRule implements IRule {

	protected static final EReference components = CorePackage.Literals.PROJECT__COMPONENTS;

	@Override
	public boolean enabled(final EObject sourceElement) throws Exception  {
		if (sourceElement instanceof AbstractRegion && sourceElement.eContainer() instanceof Machine)
			return true;
		else
			return false;
	}

	@Override
	public List<TranslationDescriptor> fire(EObject sourceElement, List<TranslationDescriptor> translatedElements) throws Exception {
		List<TranslationDescriptor> ret = new ArrayList<TranslationDescriptor>();
		AbstractRegion region = (AbstractRegion)sourceElement;
		String projectName = region.getProjectName();
		Machine sourceMachine = (Machine) region.getContaining(MachinePackage.Literals.MACHINE);
		compositionMachine = Make.machine(region.getMachineName()+"_cmp", "composition machine from region: "+region.getMachineName());
		IMachineRoot sourceMachineRoot = EventBEMFUtils.getRoot(sourceMachine);
		
		if (projectName != null && projectName.length()>0){
			Project project = Make.project(region.getProjectName(), "generated by decomposition from region: "+region.getMachineName());
			//FIXME: add support for project descriptor in translator (currently all machines go in same project as source)
			ret.add(Make.descriptor(null, null , project, 1));
			project.getComponents().add(compositionMachine);
		}else{
			ret.add(Make.descriptor(findProject(region), components , compositionMachine, 1));
		}
		//TODO: be more specific about the contexts that are needed
		for (String seesName : sourceMachine.getSeesNames()){
			compositionMachine.getSeesNames().add(seesName);
		}
		
		compositionMachine.getRefinesNames().add(sourceMachine.getName());
		
		processAllocation(region, sourceMachine, compositionMachine, sourceMachineRoot);
		
		for (Event event : compositionMachine.getEvents()){
			if (!"INITIALISATION".equals(event.getName())){
				event.getRefines().add(
						(Event)Find.element(sourceMachine, sourceMachine, MachinePackage.Literals.MACHINE__EVENTS, MachinePackage.Literals.EVENT, event.getName())
						);
			}
		}
	
// Now done by sub regions
//		for (EObject ae : region.eContents()){
//			if (ae instanceof AbstractRegion){
//				if (((AbstractRegion)ae).isReady()){
//					MachineInclusion inclusion = machineInclusion((AbstractRegion)ae, sourceMachine);
//					targetMachine.getExtensions().add(inclusion);
//				}else{
//					processAllocation((AbstractRegion)ae, sourceMachine, targetMachine, sourceMachineRoot);
//				}
//			}
//		}

		//get possible extensions
		EList<AbstractExtension> extensions = sourceMachine.getExtensions();
		
		//add refinements of all the extensions
		for (AbstractExtension ext : extensions){
			AbstractElementRefiner refiner = ElementRefinerRegistry.getRegistry().getRefiner(ext);
			if (refiner!=null) {
				Map<EObject,EObject> copy = refiner.refine(ext, compositionMachine);
				AbstractExtension clone = (AbstractExtension) copy.get(ext);
				compositionMachine.getExtensions().add(clone);
			}
		}
		
		return ret;
	}

//	/**
//	 * @param ae 
//	 * @param sourceMachine 
//	 * @return
//	 */
//	private MachineInclusion machineInclusion(AbstractRegion ae, Machine sourceMachine) {
//		MachineInclusion  mchInc =  FeatureinclusionFactory.eINSTANCE.createMachineInclusion();
//		mchInc.setAbstractMachine(machineProxyReference(sourceMachine,ae.getMachineName()));
//		mchInc.getPrefixes().add(ae.getMachineName());
//		return mchInc;
//	}
		
	/**
	 * Constructs a reference to a machine that will exist in the future. 
	 * The machine is used to construct the URI of the proxy so the machine must 
	 * already be linked to a resource in the workspace
	 * 
	 * @param machine (must be in a resource so that it has a full URI to its final resource)
	 * @param machineName - the name of a machine that will reside in the same project as the given machine
	 * @return
	 */
	public static Machine machineProxyReference(Machine sourceMachine, String machineName) {
		Machine proxy = MachineFactory.eINSTANCE.createMachine();
		URI uri = EcoreUtil.getURI(sourceMachine);
		String fragment = uri.fragment().replace(sourceMachine.getName(),machineName);
		uri = uri.trimFragment();
		uri = uri.appendFragment(fragment);
		//set the proxy uri
		((InternalEObject)proxy).eSetProxyURI(uri);
		return proxy;
	}
}
