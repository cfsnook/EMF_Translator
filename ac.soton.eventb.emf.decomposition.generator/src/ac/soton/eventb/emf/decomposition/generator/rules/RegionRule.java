package ac.soton.eventb.emf.decomposition.generator.rules;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eventb.core.IMachineRoot;
import org.eventb.emf.core.AbstractExtension;
import org.eventb.emf.core.Project;
import org.eventb.emf.core.machine.Machine;
import org.eventb.emf.core.machine.MachinePackage;
import org.eventb.emf.persistence.EventBEMFUtils;

import ac.soton.emf.translator.TranslationDescriptor;
import ac.soton.emf.translator.configuration.IRule;
import ac.soton.eventb.decomposition.AbstractRegion;
import ac.soton.eventb.emf.core.extension.navigator.refiner.AbstractElementRefiner;
import ac.soton.eventb.emf.core.extension.navigator.refiner.ElementRefinerRegistry;
import ac.soton.eventb.emf.decomposition.generator.Make;

/**
 * Rule for level 1 regions.
 * 
 * These are the decomposed sub-regions and become the root of the region model in the 
 * sub-machine that they define.
 * <p>
 * 
 * </p>
 * 
 * @author cfs
 * @version
 * @see
 * @since
 */
public class RegionRule extends AbstractRegionRule implements IRule {


	/**
	 * This rule translates regions into machines that represent sub components
	 * Currently the region must be contained in a root region that is itself contained in a machine
	 * (the root region represents the current (source) machine)
	 * Currently we only decompose one level at a time (even if lower levels are marked as ready)
	 * 
	 */
	@Override
	public boolean enabled(final EObject sourceElement) throws Exception  {
		if (sourceElement.eContainer() instanceof AbstractRegion &&
			sourceElement.eContainer().eContainer() instanceof Machine	&&
			((AbstractRegion)sourceElement).isReady())
			return true;
		else
			return false;
	}

	@Override
	public List<TranslationDescriptor> fire(EObject sourceElement, List<TranslationDescriptor> translatedElements) throws Exception {
		List<TranslationDescriptor> ret = new ArrayList<TranslationDescriptor>();
		AbstractRegion region = (AbstractRegion)sourceElement;
		String projectName = region.getProjectName();
		Machine sourceMachine = (Machine) region.getContaining(MachinePackage.Literals.MACHINE);
		Machine decomposedMachine = Make.machine(region.getMachineName(), "generated by decomposition from region: "+region.getMachineName());
		IMachineRoot sourceMachineRoot = EventBEMFUtils.getRoot(sourceMachine);
		
		if (projectName != null && projectName.length()>0){
			Project project = Make.project(region.getProjectName(), "generated by decomposition from region: "+region.getMachineName());
			//FIXME: add support for project descriptor in translator (currently all machines go in same project as source)
			ret.add(Make.descriptor(null, null , project, 1));
			project.getComponents().add(decomposedMachine);
		}else{
			ret.add(Make.descriptor(findProject(region), components , decomposedMachine, 1));
		}
		for (String seesName : sourceMachine.getSeesNames()){
			decomposedMachine.getSeesNames().add(seesName);
		}
		
		processAllocation(region, sourceMachine, decomposedMachine, sourceMachineRoot);

		
		//get any allocated extensions
		EList<AbstractExtension> extensions = region.getAllocatedExtensions();
		
		// also promote any nested extensions (including nested regions)
		extensions.addAll(region.getExtensions());
		
		//add clones of all the extensions
		for (AbstractExtension ext : extensions){
			AbstractElementRefiner refiner = ElementRefinerRegistry.getRegistry().getRefiner(ext);
			if (refiner!=null) {
				Map<EObject,EObject> copy = refiner.cloneAndExtractFromRefinementChain(ext, decomposedMachine,null);
				AbstractExtension clone = (AbstractExtension) copy.get(ext);
				decomposedMachine.getExtensions().add(clone);
			}
		}

		return ret;
	}

		
}
