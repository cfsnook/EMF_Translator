package ac.soton.eventb.emf.decomposition.generator.rules;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eventb.core.IMachineRoot;
import org.eventb.emf.core.AbstractExtension;
import org.eventb.emf.core.Project;
import org.eventb.emf.core.machine.Machine;
import org.eventb.emf.core.machine.MachinePackage;
import org.eventb.emf.persistence.EventBEMFUtils;

import ac.soton.emf.translator.TranslationDescriptor;
import ac.soton.emf.translator.configuration.IRule;
import ac.soton.emf.translator.utils.Find;
import ac.soton.eventb.decomposition.AbstractRegion;
import ac.soton.eventb.emf.core.extension.navigator.refiner.AbstractElementRefiner;
import ac.soton.eventb.emf.core.extension.navigator.refiner.ElementRefinerRegistry;
import ac.soton.eventb.emf.decomposition.generator.Make;
import ac.soton.eventb.featureinclusion.FeatureinclusionFactory;
import ac.soton.eventb.featureinclusion.MachineInclusion;

/**
 * Rule for level 1 regions... ready or not.
 * 
 * If ready, these are the decomposed sub-regions and become the root of the region model in the 
 * sub-machine that they define. If not ready they are contained in the composed machine
 * <p>
 * This rule translates regions into machines that represent sub components
 * Currently the region must be contained in a root region that is itself contained in a machine
 * (the root region represents the current (source) machine)
 * Currently we only decompose one level at a time (even if lower levels are marked as ready)
 * </p>
 * 
 * @author cfs
 * @version
 * @see
 * @since
 */
public class RegionRule extends AbstractRegionRule implements IRule {

	private Machine compositionMachine = null;
	
	/**
	 * the region must be contained in a root region
	 */
	@Override
	public boolean enabled(final EObject sourceElement) throws Exception  {
		if (sourceElement.eContainer() instanceof AbstractRegion
			&& sourceElement.eContainer().eContainer() instanceof Machine 
			//&& ((AbstractRegion)sourceElement).isReady()
			)
			return true;
		else
			return false;
	}

	/**
	 * the composition machine must be produced first
	 */
	@Override
	public boolean dependenciesOK(EObject sourceElement,List<TranslationDescriptor> translatedElements){
		String composedMachineName = ((AbstractRegion)sourceElement.eContainer()).getMachineName();
		compositionMachine = (Machine) Find.translatedElement(translatedElements, null, components, machine, composedMachineName);
		return compositionMachine!=null;
		
	}
	
	
	@Override
	public List<TranslationDescriptor> fire(EObject sourceElement, List<TranslationDescriptor> translatedElements) throws Exception {
		List<TranslationDescriptor> ret = new ArrayList<TranslationDescriptor>();
		AbstractRegion region = (AbstractRegion)sourceElement;
		String projectName = region.getProjectName();
		Machine sourceMachine = (Machine) region.getContaining(MachinePackage.Literals.MACHINE);
		IMachineRoot sourceMachineRoot = EventBEMFUtils.getRoot(sourceMachine);
		
		if (region.isReady()){

			Machine decomposedMachine = Make.machine(region.getMachineName(), "generated by decomposition from region: "+region.getMachineName());

			if (projectName != null && projectName.length()>0){
				Project project = Make.project(region.getProjectName(), "generated by decomposition from region: "+region.getMachineName());
				//FIXME: add support for project descriptor in translator (currently all machines go in same project as source)
				ret.add(Make.descriptor(null, null , project, 1));
				project.getComponents().add(decomposedMachine);
			}else{
				ret.add(Make.descriptor(findProject(region), components , decomposedMachine, 1));
			}
			//TODO: be more specific about the contexts that are needed
			for (String seesName : sourceMachine.getSeesNames()){
				decomposedMachine.getSeesNames().add(seesName);
			}
			
			processAllocation(region, sourceMachine, decomposedMachine, sourceMachineRoot);
	
			
			//get any allocated extensions
			EList<AbstractExtension> extensions = region.getAllocatedExtensions();
			
			// also promote any nested extensions (including nested regions)
			extensions.addAll(region.getExtensions());
			
			//add clones of all the extensions
			for (AbstractExtension ext : extensions){
				AbstractElementRefiner refiner = ElementRefinerRegistry.getRegistry().getRefiner(ext);
				if (refiner!=null) {
					Map<EObject,EObject> copy = refiner.cloneAndExtractFromRefinementChain(ext, decomposedMachine,null);
					AbstractExtension clone = (AbstractExtension) copy.get(ext);
					decomposedMachine.getExtensions().add(clone);
				}
			}
			
			//add includes to composition machine
			MachineInclusion inclusion = FeatureinclusionFactory.eINSTANCE.createMachineInclusion();
			inclusion.setAbstractMachine(decomposedMachine);
			inclusion.getPrefixes().add(region.getMachineName());
			//TODO:add event syncs
			compositionMachine.getExtensions().add(inclusion);
			
		}else{
			//when region is not ready its allocation is added to the compositionMachine
			processAllocation(region, sourceMachine, compositionMachine, sourceMachineRoot);
		}

		return ret;
	}

		
}
