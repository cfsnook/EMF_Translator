\section{Tasking Event-B}\label{TEB}
In this section we begin our presentation of Tasking Event-B. We begin by describing the Event-B semantics of the notation. An Event-B model is an abstraction of a system, the evolution of the state is described using events. The guard of an event describes the conditions which must hold prior to an event being enabled. The actions describe the values of the state variables after the event has occurred. Proof obligations are generated, to ensure that the actions update the state with values that satisfy invariant. As a result, a system that is consistent, can be described using events that do not impose an ordering: since in Event-B any enabled event can occur.

Now, in an implementation-level specification wish to reason about task-like behaviour, with implementation constructs, such as sequencing. So we introduce a notation for the purpose of ordering of events. The notation can be used to assist with code generation, since it allows the developer to introduce an ordering where none might exist. In the case that such an ordering does exist in the abstraction, the developer can generate a new Event-B model from the notation, and show that it a refinement of the more abstract one.  When considering translation to code, it is usually necessary to work with a subset of implementable Event-B constructs. We consider \emph{implementable constructs} to be those that are available in (or map well to) a programming language. We would therefore usually not consider non-deterministic assignment to be implementable, for instance, and add a restriction; that these are `refined out' of the implementation-level model. Annotations are added to both machines and contexts. As well as assisting with code generation, the annotations are used to generate an Event-B model of the implementation. In Subsect.~\ref{flow} we introduce the notation for specifying control flow, and provide Event-B, and implementation, semantics for this. In Subsect.~\ref{tasks} we discuss how we relate tasks, and protected objects, to Event-B machines.

In the following discussion, we distinguish between a task's behaviour, such as it's life-cycle (which is not modelled formally) necessary for implementation; and the updates to state (which are modelled formally). Our notation allows specification of both, formal and non-formal, aspects of a specification. An example of a non-formal aspect, is the task type which might be periodic or one-shot. Specifying that a task should repeat every so often, or happen just once. 



 
\subsection{Flow Control for Events}\label{flow}
To enable us to impose an order on events we introduce \emph{Tasking Event-B}, a textual extension to standard Event-B. The first notion we will look at is sequential ordering, for which we introduce a semi-colon `;' sequence operator. In a model with two events \emph{evt1} and \emph{evt2}, we can write \emph{evt1;evt2} to specify a sequential ordering. We can provide Event-B semantics for the ordering, by introducing an abstract program counter to the model. An enumeration of constants models the abstract program counter values; one per event. An abstract program counter variable models the currently enabled event. Guards enforce the ordering, and actions update the abstract program counter. An example can be seen in Fig.~\ref{fig:seq}, where the program counter constants are \emph{evt1} and \emph{evt2}, \emph{pc} has type \emph{pcValues}, and the program counter enumeration is defined by a partition, using the Event-B partition operator, so $partition(pcValues, \{evt1\}, \{evt2\},\{term\})$. The partition means that the values of the enumeration are distinct, i.e. $evt1 \neq evt2$ and so on. \emph{term} is label indicating a final state where no event is enabled.
%
\begin{figure}
\centering
\begin{minipage}{0.7\textwidth}
Variables evt1, evt2\\
Invariant pc $\in pcValue$ \\
Initialisation = pc $\bcmeq$ evt1 \\
evt1 = \textbf{WHEN}~ pc = evt1~ \textbf{THEN}~$A_1~ \pprod$ pc $\bcmeq$ evt2 \textbf{END}\\
evt2 = \textbf{WHEN}~ pc = evt2~ \textbf{THEN}~$A_2~ \pprod$ pc $\bcmeq$ term \textbf{END}\\
\end{minipage}
\caption{Sequence}
\label{fig:seq}
\end{figure}
Initially $evt1$ is enabled and $evt2$ is disabled, since $pc = evt1$. The update action $A_1$ occurs, with the program counter being set \emph{evt2}. This, in turn, enables $evt2$, and so on.
\subsection{Translating Sequences of Events}
We will now define some translation functions for translating Tasking Event-B to Event-B. These functions effectively add program counter guards, and actions to the event. In the first instance, the abstract syntax of TEB ::= EVENT $|$ SEQ, where the concrete syntax of a sequence \emph{SEQ} is a semi-colon `;'. When translating sequences of events, we assume that events have no guards other than the program counter guards. To add the guards and actions modelling a program step, seen in Fig.~\ref{fig:seq}, we define a translation $TEB\_{pc}$. It takes, as parameters, a Tasking Event-B construct, and the next program counter name. It returns a set of events. The $TEB_{pc}$ function is polymorphic on its inputs, with a different function application for each Tasking Event-B construct.
%
\begin{equation}
TEB_{pc} \in  TEB \cprod Name \rightarrow POW(EVENT)
\notag
\end{equation}
%
We use a function \emph{pcName} to extract an event name from an event; the name is used as a program counter variable. When $TEB_{pc}$ is applied to a sequence, it returns two events, with $TEB_{pc}$ applied to the individual events. 
%
\begin{equation}
\begin{split}
&TEB_{pc}(e_1 ; e_2, x) \leadsto \\
\{~&TEB_{pc}(e_1, pcName(e_2)),\\
&TEB_{pc}(e_2, x)~\}
\end{split}
\notag
\end{equation}
%
The $TEB_{pc}$ function is applied to each event in the returned set. We now represent an event, with guards and actions, using the notation $g \rightarrow a$; where $g$ is the guard, and $a$ is the action. 
\begin{equation}
\begin{split}
&TEB_{pc}(e_1, x) \leadsto \\
\{~&e_1 \triangleq pc = pcName(e_1) \rightarrow ( a_1 \pprod pc \bcmeq x )~\}
\end{split}
\notag
\end{equation}
This returns an updated event, with the additional guards and actions modelling a program pc.

The translation to code for a sequence is relatively straightforward. We simply map the concrete sequence operator to a statement delimiter, expand the event actions, and add a terminating delimiter in the appropriate place. One further consideration is the translation of parallel assignments to sequential, where care must be taken to translate variables on the right hand side of assignments to a local variable representing the initial values of those variables. First we define a translation function that maps from Tasking Event-B to program statements in our common language abstraction.   
\begin{equation}
TEB_{clm} \in  TEB \rightarrow ProgramStatements
\notag
\end{equation}
To resolve the mapping from parallel to sequential we define a function which generates program statements from the event $ACTIONS$. 
\begin{equation}
TEB_{iniValSubs} \in  ACTIONS \rightarrow ProgramStatements
\notag
\end{equation}
In the $TEB_{iniValSubs}$, function we translate assignments of the form $l \bcmeq E(V)$ to program assignments. Here, $l$ is a single variable identifier on the lhs of the assignment, and  E(V) represents expressions involving a set of variables $V$ on the right hand side. For each variable $v \in V$ we insert in the translated statements, a local variable of the same type as v.It is initialised so that $v_{ini} \bcmeq v$. We replace occurrences of $v$ in E(V) with $v_{ini}$. The translation function applied to the an event is therefore defined as a further translation,
%
\begin{equation}
\begin{split}
&TEB_{clm}(e_1) \leadsto \\
&TEB_{iniValSubs}(a_1)
\end{split}
\notag
\end{equation}
%
As an example, $a_1$ may be a parallel assignment, where $x \bcmeq y \pprod y \bcmeq x$. To translate this we have,
%
\begin{equation}
\begin{split}
&TEB_{iniValSubs}(x \bcmeq y \pprod y \bcmeq x) \leadsto\\
&y_{ini} \bcmeq y;~ x_{ini} \bcmeq x;~ x \bcmeq y_{ini};~ y \bcmeq x_{ini}  
\end{split}
\notag
\end{equation}
%  
\subsection{Branching}
To introduce branching to Tasking Event-B we consider the simple case first, where we have two events $e_1 = g \rightarrow a_1$ and $e_2 = \lnot g \rightarrow a_2$. We add to the syntax, IF $e_1$ ELSE $e_2$ END. The translation function takes the branch as an argument, adds the program counter information, and returns the set of updated Events. We assume that a proof obligation is generated, whereby we can show that the guards are disjoint and cover all cases.
%
\begin{equation}
\begin{split}
&TEB_{pc}(IF~ e_1~ ELSE~ e_2,~  x) \leadsto\\
& \{~ e_1 \triangleq (g_1 \land pc = pcName(e_1)) \rightarrow (a_1 \pprod pc \bcmeq x),\\
&\hspace*{0.3cm}e_2 \triangleq (\lnot g_1 \land pc = pcName(e_1)) \rightarrow (a_2 \pprod pc \bcmeq x) \}
\end{split}
\notag
\end{equation}
%
In the branching case, both events share the same enabling program counter. Instead the ordering is determined by the guard $g_1$ or $\lnot g_1$, and both branches take the same next program counter value. 

The translation to the common language model, is as follows.
\begin{equation}
\begin{split}
&TEB_{clm}(IF~ e_1~ ELSE~ e_2) \leadsto\\
& if(g_1)\{ TEB_{iniValSubs}(a_1) \} \\
& else\{TEB_{iniValSubs}(a_2) \}
\end{split}
\notag
\end{equation}

\subsection{Looping}
The Tasking Event-B while loop is written \emph{WHILE e1 END}. This simple loop repeats \emph{e1} while the guard is true. It has the following Event-B semantics for which we provide the translation,

\begin{equation}
\begin{split}
&TEB_{pc}(WHILE~ e_1,~  x) \leadsto\\
& \{~ e_1 \triangleq (g_1 \land pc = pcName(e_1)) \rightarrow (a_1 ),\\
&\hspace*{0.3cm}e_2 \triangleq (\lnot g_1 \land pc = pcName(e_1)) \rightarrow (pc \bcmeq x) \}
\end{split}
\notag
\end{equation}

The translation to the common language model, is as follows.
\begin{equation}
\begin{split}
&TEB_{clm}(WHILE~ e_1 ) \leadsto\\
& while(g_1)\{ TEB_{iniValSubs}(a_1) \}
\end{split}
\notag
\end{equation}

We will not explicitly give details of the translation of Tasking Event-B constructs from the CLM to the implementations in target languages, since we anticipate that the CLM constructs represent implementation constructs in an `obvious' way. 

\subsection{Tasks and Shared Machines}\label{tasks}
In our implementations we wish to describe two kinds of behaviour. The first is the behaviour of the task-like scheduling of activities (described by the ordering of events) specified in the Task Body, using the Tasking Event-B constructs introduced earlier in the section. The second is the behaviour of shared machines, which provide a means to share information between the tasks. Shared machines have no flow control specification of their own (i.e. no event ordering). They instead, rely on the synchronization of events arising from the decomposition, which is recorded in the composed machine structure. The events in the shared machine synchronize with the corresponding events in tasks, and contains enough information to construct an implementation. 

Tasking machines therefore consist of an Event-B machine with a task-body annotation describing the event ordering. There are two types of tasking machines, one describing the controller tasks in the system; the other describing the environment. These are known as \emph{Autotask} and \emph{Environ} machines respectively. The main difference between a model of a controller, and a model of the environment, is that it is intended that a controller task is refined down to an implementation which can be deployed on the target system. The environment model is usually an abstract model of the environment. The generated code can be discarded if required, although it is possible to generate a Java-style interface, or re-use the generated Ada procedures. The interface (or modified Ada procedures) can be implemented with calls to software driver APIs allowing the controller to interact with the real environment. The following table relates the Tasking Event-B construct to its implementation.
%
\begin{center}
\begin{tabular}{l|l}
Tasking Event-B & Implementation \\ 
\hline
AutoTask Machine & Deployable Task\\
Shared Machine &	Protected Object\\
Environ Machine &	Simulation Task and Interface
\end{tabular}
\end{center}
%
In the CLM we have a `generic' autoTask element, derived from the Tasking Event-B aouttask. The actual implementation may be in any language, but we define the semantics in terms of the Ada task, when specified in an Ada main procedure body. Ada tasks defined in this way start as soon as possible, near the beginning of a program execution. But no explicit ordering is imposed on their start-up, and  the number of tasks is fixed, determined by the number of machines in the development. The autotask might also be implemented as a Java thread, or a POSIX pthread in C; in this case the implementation should reflect that of the Ada implementation as far as possible.

 The autoTask construct, in the CLM, has a task-body containing an expansion of the tasking constructs, obtained from the application the previously introduced translation rules. The task body may contain sequences, and branches, etc. but will still contain the original Event-B predicates and expressions. Translation of these will take place in the second step, which involves the use of the theory plug-in. Ultimately autotasks are used to model a system's controllers, and translations from them will be deployed on the target system.

In the same way as autotasks are related to Ada tasks, Shared Machines are related to Ada protected objects. The protected objects provide mutually exclusive access to private data. In our translation all machine variables are translated to private variables, so it is necessary to use the object's procedures to access the data. Protected objects are owned by a task, and used to share information between tasks. Implementations in other languages may need to provide thier own mutual exclusion mechanisms, such as using Java's synchronized constructs. 

As we have already stated, Environ Machines model the environment, and their implementation is similar to an autotask's, with the exception that we allow direct communication between autotasks, and environ tasks. This is possible because we implement Ada tasks for the purposes of simulation; the environment tasks can have Ada entries. These are used in the rendezvous communication style. This allows controller implementations to poll, and set, environment values using an entry call. Ada is unusual in that it has this mechanism as a language construct. Similar implementations should be achievable in other languages.

\subsection{Theories for TEB}

\subsection{State-machines}