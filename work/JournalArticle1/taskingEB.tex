\section{Tasking Event-B}\label{TEB}
In this section we begin our presentation of Tasking Event-B. We begin by describing the Event-B semantics of the notation. An Event-B model is an abstraction of a system, the evolution of the state is described using events. The guard of an event describes the conditions which must hold prior to an event being enabled. The actions describe the values of the state variables after the event has occurred. Proof obligations are generated, to ensure that the actions update the state with values that satisfy invariant. As a result, a system that is consistent, can be described using events that do not impose an ordering: since in Event-B any enabled event can occur.

Now, in an implementation-level specification wish to reason about task-like behaviour, with implementation constructs, such as sequencing. So we introduce a notation for the purpose of ordering of events. The notation can be used to assist with code generation, since it allows the developer to introduce an ordering where none might exist. In the case that such an ordering does exist in the abstraction, the developer can generate a new Event-B model from the notation, and show that it a refinement of the more abstract one.  When considering translation to code, it is usually necessary to work with a subset of implementable Event-B constructs. We consider \emph{implementable constructs} to be those that are available in (or map well to) a programming language. We would therefore usually not consider non-deterministic assignment to be implementable, for instance, and add a restriction; that these are `refined out' of the implementation-level model. Annotations are added to both machines and contexts. As well as assisting with code generation, the annotations are used to generate an Event-B model of the implementation. In Subsect.~\ref{flow} we introduce the notation for specifying control flow, and provide Event-B, and implementation, semantics for this. In Subsect.~\ref{tasks} we discuss how we relate tasks, and protected objects, to Event-B machines.

In the following discussion, we distinguish between a task's behaviour, such as it's life-cycle (which is not modelled formally) necessary for implementation; and the updates to state (which are modelled formally). Our notation allows specification of both, formal and non-formal, aspects of a specification. An example of a non-formal aspect, is the task type which might be periodic or one-shot. Specifying that a task should repeat every so often, or happen just once. 



 
\subsection{Flow Control for Events}\label{flow}
To enable us to impose an order on events we introduce \emph{Tasking Event-B}, a textual extension to standard Event-B. The first notion we will look at is sequential ordering, for which we introduce a semi-colon `;' sequence operator. In a model with two events \emph{evt1} and \emph{evt2}, we can write \emph{evt1;evt2} to specify a sequential ordering. We can provide Event-B semantics for the ordering, by introducing an abstract program counter to the model. An enumeration of constants models the abstract program counter values; one per event. An abstract program counter variable models the currently enabled event. Guards enforce the ordering, and actions update the abstract program counter. An example can be seen in Fig.~\ref{fig:seq}, where the program counter constants are \emph{evt1} and \emph{evt2}, \emph{pc} has type \emph{pcValues}, and the program counter enumeration is defined by a partition, using the Event-B partition operator, so $partition(pcValues, \{evt1\}, \{evt2\},\{term\})$. The partition means that the values of the enumeration are distinct, i.e. $evt1 \neq evt2$ and so on. \emph{term} is label indicating a final state where no event is enabled.
%
\begin{figure}
\centering
\begin{minipage}{0.7\textwidth}
Variables evt1, evt2\\
Invariant pc $\in pcValue$ \\
Initialisation = pc $\bcmeq$ evt1 \\
evt1 = \textbf{WHEN}~ pc = evt1~ \textbf{THEN}~$A_1~ \pprod$ pc $\bcmeq$ evt2 \textbf{END}\\
evt2 = \textbf{WHEN}~ pc = evt2~ \textbf{THEN}~$A_2~ \pprod$ pc $\bcmeq$ term \textbf{END}\\
\end{minipage}
\caption{Sequence}
\label{fig:seq}
\end{figure}
Initially $evt1$ is enabled and $evt2$ is disabled, since $pc = evt1$. The update action $A_1$ occurs, with the program counter being set \emph{evt2}. This, in turn, enables $evt2$, and so on.
\subsection{Translating Sequences of Events}
We will now define some translation functions for translating Tasking Event-B to Event-B. These functions effectively add program counter guards, and actions to the event. In the first instance, the abstract syntax of TEB ::= EVENT $|$ SEQ, where the concrete syntax of a sequence \emph{SEQ} is a semi-colon `;'. When translating sequences of events, we assume that events have no guards other than the program counter guards. To add the guards and actions modelling a program step, seen in Fig.~\ref{fig:seq}, we define a translation $TEB\_{pc}$. It takes, as parameters, a Tasking Event-B construct, and the next program counter name. It returns a set of events. The $TEB_{pc}$ function is polymorphic on its inputs, with a different function application for each Tasking Event-B construct.
%
\begin{equation}
TEB_{pc} \in  TEB \cprod Name \rightarrow POW(EVENT)
\notag
\end{equation}
%
We use a function \emph{pcName} to extract an event name from an event; the name is used as a program counter variable. When $TEB_{pc}$ is applied to a sequence, it returns two events, with $TEB_{pc}$ applied to the individual events. 
%
\begin{equation}
\begin{split}
&TEB_{pc}(e_1 ; e_2, x) \leadsto \\
\{~&TEB_{pc}(e_1, pcName(e_2)),\\
&TEB_{pc}(e_2, x)~\}
\end{split}
\notag
\end{equation}
%
The $TEB_{pc}$ function is applied to each event in the returned set. We now represent an event, with guards and actions, using the notation $g \rightarrow a$; where $g$ is the guard, and $a$ is the action. 
\begin{equation}
\begin{split}
&TEB_{pc}(e_1, x) \leadsto \\
\{~&e_1 \triangleq pc = pcName(e_1) \rightarrow ( a_1 \pprod pc \bcmeq x )~\}
\end{split}
\notag
\end{equation}
This returns an updated event, with the additional guards and actions modelling a program pc.

The translation to code for a sequence is relatively straightforward. We simply map the concrete sequence operator to a statement delimiter, expand the event actions, and add a terminating delimiter in the appropriate place. One further consideration is the translation of parallel assignments to sequential, where care must be taken to translate variables on the right hand side of assignments to a local variable representing the initial values of those variables. First we define a translation function that maps from Tasking Event-B to program statements in our common language abstraction.   
\begin{equation}
TEB_{clm} \in  TEB \rightarrow ProgramStatements
\notag
\end{equation}
To resolve the mapping from parallel to sequential we define a function which generates program statements from the event $ACTIONS$. 
\begin{equation}
TEB_{iniValSubs} \in  ACTIONS \rightarrow ProgramStatements
\notag
\end{equation}
In the $TEB_{iniValSubs}$, function we translate assignments of the form $l \bcmeq E(V)$ to program assignments. Here, $l$ is a single variable identifier on the lhs of the assignment, and  E(V) represents expressions involving a set of variables $V$ on the right hand side. For each variable $v \in V$ we insert in the translated statements, a local variable of the same type as v.It is initialised so that $v_{ini} \bcmeq v$. We replace occurrences of $v$ in E(V) with $v_{ini}$. The translation function applied to the an event is therefore defined as a further translation,
%
\begin{equation}
\begin{split}
&TEB_{clm}(e_1) \leadsto \\
&TEB_{iniValSubs}(a_1)
\end{split}
\notag
\end{equation}
%
As an example, $a_1$ may be a parallel assignment, where $x \bcmeq y \pprod y \bcmeq x$. To translate this we have,
%
\begin{equation}
\begin{split}
&TEB_{iniValSubs}(x \bcmeq y \pprod y \bcmeq x) \leadsto\\
&y_{ini} \bcmeq y;~ x_{ini} \bcmeq x;~ x \bcmeq y_{ini};~ y \bcmeq x_{ini}  
\end{split}
\notag
\end{equation}
%  
\subsection{Branching}
To introduce branching to Tasking Event-B we consider the simple case first, where we have two events $e_1 = g \rightarrow a_1$ and $e_2 = \lnot g \rightarrow a_2$. We add to the syntax, IF $e_1$ ELSE $e_2$ END. The translation function takes the branch as an argument, adds the program counter information, and returns the set of updated Events. We assume that a proof obligation is generated, whereby we can show that the guards are disjoint and cover all cases.
%
\begin{equation}
\begin{split}
&TEB_{pc}(IF~ e_1~ ELSE~ e_2,~  x) \leadsto\\
& \{~ e_1 \triangleq (g_1 \land pc = pcName(e_1)) \rightarrow (a_1 \pprod pc \bcmeq x),\\
&\hspace*{0.3cm}e_2 \triangleq (\lnot g_1 \land pc = pcName(e_1)) \rightarrow (a_2 \pprod pc \bcmeq x) \}
\end{split}
\notag
\end{equation}
%
In the branching case, both events share the same enabling program counter. Instead the ordering is determined by the guard $g_1$ or $\lnot g_1$, and both branches take the same next program counter value. 

The translation to the common language model, is as follows.
\begin{equation}
\begin{split}
&TEB_{clm}(IF~ e_1~ ELSE~ e_2) \leadsto\\
& if(g_1)\{ TEB_{iniValSubs}(a_1) \} \\
& else\{TEB_{iniValSubs}(a_2) \}
\end{split}
\notag
\end{equation}

\subsection{Looping}
The Tasking Event-B while loop is written \emph{WHILE e1 END}. This simple loop repeats \emph{e1} while the guard is true. It has the following Event-B semantics for which we provide the translation,

\begin{equation}
\begin{split}
&TEB_{pc}(WHILE~ e_1,~  x) \leadsto\\
& \{~ e_1 \triangleq (g_1 \land pc = pcName(e_1)) \rightarrow (a_1 ),\\
&\hspace*{0.3cm}e_2 \triangleq (\lnot g_1 \land pc = pcName(e_1)) \rightarrow (pc \bcmeq x) \}
\end{split}
\notag
\end{equation}

The translation to the common language model, is as follows.
\begin{equation}
\begin{split}
&TEB_{clm}(WHILE~ e_1 ) \leadsto\\
& while(g_1)\{ TEB_{iniValSubs}(a_1) \}
\end{split}
\notag
\end{equation}

We will not explicitly give details of the translation of Tasking Event-B constructs from the CLM to the implementations in target languages, since we anticipate that the CLM constructs represent implementation constructs in an `obvious' way. 

\subsection{Tasks and Shared Machines}\label{tasks}
In our implementations we wish to describe two kinds of behaviour. The first behaviour is the task-like behaviour of the \emph{tasking machine} machine. We impose an ordering on the events of a machine, to describe the activities that take place when the task is active. We model this in an extension to Event-B, using a \emph{task-body} and the Tasking Event-B constructs introduced earlier in the section. The task-body, with its tasking notation, provides programming-style specification in Event-B. This is readily translated to the CLM and to Event-B. The second behaviour is that of the shared machine type, which provides a means to share information between the tasks. Shared machines have no flow control specification of their own (i.e. no event ordering). They rely on the task-body, and synchronization of events. The synchronizations arise from the decomposition process, and are recorded in the composed machine structure. The events in the shared machine synchronize with the corresponding events in tasks; it is through this that we translate to a procedure, and its call, in the implementation. 

There are two types of tasking machines, one describing the controller tasks in the system; the other describing the environment. These are known as \emph{Autotask} and \emph{Environ} machines respectively. The main difference between a model of a controller, and a model of the environment, is that it is intended that a controller task is refined down to an implementation which can be deployed on the target system. The environment model is usually an abstract model of the environment. The generated code can be discarded if required, although it is possible to generate a Java-style interface, or re-use the generated Ada procedures. The interface (or modified Ada procedures) can be implemented with calls to software driver APIs allowing the controller to interact with the real environment. The following table relates the Tasking Event-B constructs to their implementable types.
%


We now consider how communication between machines, with event synchronization, is translated. In a synchronization there is a ‘local’ event and a ‘remote’ event, with respect to a task. We say that a local event is the one belonging to the task; a remote event is the event belonging to the shared machine. Synchronization occurs between a pair of events; one from a Tasking Machine, and one from a Shared Machine or Environ Machine. The synchronization of the two events is equivalent to a single atomic event, with the guards and actions of the individual events merged. We can write the guards and actions of the events as guarded commands~\cite{Dijkstra75a}. The general case of event synchronization is shown in Equation~\ref{kjh} where a local event $e_l$ is written as $g_l \rightarrow a_l$ , and $g_l$ and $a_l$ are local guards and actions. The remote event $e_r$ is written $g_r \rightarrow a_r$ , where $g_r$ and
$a_r$ are remote guards and actions. The synchronization of one local and one
remote event uses the event composition operator $e$ . The actions describing
state updates are composed with the parallel update operator .

\begin{equation}\label{kjh}
abc
\end{equation}


\begin{center}
\begin{tabular}{l|l}
Tasking Event-B & Implementation \\ 
\hline
AutoTask Machine & Deployable Task\\
Shared Machine &	Protected Object\\
Environ Machine &	Simulation Task and Interface
\end{tabular}
\end{center}
%
In the CLM we have a `generic' autoTask element, generated from the Tasking Event-B \emph{autotask}. The final implementation depends on the selected target language. To define the semantics of the CLM artefacts we use Ada programming semantics, since it is well defined~\cite{ada2005}. The \emph{main} Ada program may contain static task definitions in it declarative part. The tasks defined here, start after elaboration of the declarative part. This behaviour is modelled by the Event-B model, where each static task is modelled by an \emph{autotask} machine. There is no explicit ordering imposed on their start-up, and  the number of tasks is fixed, since it is determined by the number of machines in the development. The autotask can also be implemented as a Java thread, or a POSIX pthread in C; in this case the implementation should implement the Ada semantics.

 The autoTask construct, in the CLM, has a task-body containing an representation of the tasking constructs, obtained from the application the previously introduced translation rules. The task body may contain sequences, and branches, etc. but still contains Event-B predicates and expressions. Translation of these will take place in the second step, which involves the use of the theory plug-in. Autotasks are used to model a system's controllers, and it is intended that their translations will be deployed on the target system.

In the same way as autotasks are related to Ada tasks, Shared Machines are related to Ada protected objects. The protected objects provide mutually exclusive access to private data. In our translation all machine variables are translated to private variables, so it is necessary to use the object's procedures to access the data. Protected objects are owned by a task, and used to share information between tasks. Implementations in other languages may need to provide their own mutual exclusion mechanisms, such as using Java's synchronized constructs. 

Environ Machines model the environment, and their implementation is similar to an autotask's, with the exception that we allow direct communication between autotasks, and environ tasks. Ordinarily we prohibit inter-task communication, but here it is possible because we use Ada tasks for simulation; the environment tasks can have Ada entries. These are used in the rendezvous communication style. This allows controller implementations to poll, and set, environment values using an entry call. Ada is unusual in that it has this mechanism as a language construct. Similar implementations should be achievable in other languages.

Translations of Tasking Machine to CLM  Task
Invariants are not used.

\begin{tabular}{l|l}
Machine Element & Common Language Element \\
\hline
Variables + Typing Invariants  &	Variable Declaration\\
\hline
task body & task body\\
Local Events & Expand actions in-line \\
Synchronizing Events & Procedure + Call

\end{tabular}


Contexts
Constants	  Constants
partition		 enumeration

Machine
as in eventB +
Task 

Task 
task type
priority
task body

task type
simple
periodic

simple
repeat
one-shot

simple



tasking machine

\subsection{Theories for TEB}

\subsection{State-machines}