\section{Conclusions}
\subsection{Discussion}

\subsection{Related Work}
As we mentioned in the introduction, the main driver for this work has been to derive the greatest benefit from the formal modelling approach, by making use of the formal modelling artefacts to generate implementations. There are many formal notations and many have support for automatic code-generation.

The Classical-B~\cite{TheBBook} approach made use of an implementation-level notation called \emph{B0}, described in~\cite{B0RefMan}. B0 is similar to a programming language, and consists only of concrete programming constructs. These constructs map to programming constructs in a number of programming languages. \emph{B0} forms part of the Classical-B refinement chain, so the implementation-level specification refines the abstract development. Translators are available targeting programming languages such as C~\cite{KernighanR88}, and $High~ Integrity~ Ada$ (based on $SPARKAda$~\cite{SPARKAda}). 

The \emph{Z-notation} is a state-based specification notation (actually a distant ancestor of Event-B).  

The VDM-SL is a state-based formal specification language, related to $Z$, and has tool support for automatic code generation. 

VDM++ is an object-oriented extension to Models can be described textually; or using a graphical interface using UML diagrams, in much the same way as UML-B does for B and Event-B. VDM++ can be used with the VDM++ Toolbox to generate C++ and Java code. VDM++ can be used to model and implement developments with concurrently executing processes, using threads.

\emph{Object-Z}~\cite{GSmith2000} is an object-oriented approach to development using $Z$. A route to implementation is described using a translation to \emph{PerfectDeveloper}~\cite{PD} in~\cite{Stevens06}. \emph{PerfectDeveloper}'s approach is to use verified-Design By Contract, where verification conditions are generated from a specification using constructs such as pre and postconditions, class and loop invariants, and assertions. The verification conditions must be shown to hold in order to show the specified contracts are satisfied by the implementation. They are generated for each method entry to show that the precondition holds, for each method exit to show that the postcondition holds, and wherever an assertion appears. \emph{PerfectDeveloper} provides automatic, and semi-automatic, translations to Java and C++ but appears not to support concurrent processing.

There are some combined formal approach where code-generation has been investigated. CSP~\cite{HO85CSP,Roscoe1997} is a process algebraic approach to system specification in which the ordering of events occurring in a system play a major role. CSP specifications have been translated into Java code using JCSP~\cite{JCSPNet,JCSPMulti}. A hybrid CSP and Classical-B approach~\cite{SchneiderT02,SchneiderT05} combines the benefits of modelling, using both process-based and state-based techniques.  In this approach, called $CSP\pprod B$, specifications are used to constrain the order that the state-changing operations may occur; and to specify points at which the processes may interleave. The B operations synchronize with CSP events with the same name, and provide an ordering of the occurrence of B operations. ProB~\cite{LeuschelB08} is an animator and model checker for Classical-B and Event-B, and can be used with the $CSP\pprod B$ combination. It is used in the JCSProB~\cite{YangPop2007} approach, which combines CSP and Classical-B, and has a code generator inspired by JCSP. Another combined approach, amenable to model-checking, is \emph{Circus}~\cite{WoodcockC01}, which is combination of CSP and \emph{Z-notation}~\cite{Spivey89}. CSP is used to order the $Z$ operations. It can be translated to Java as described in~\cite{FreitasC06} and makes use of the JCSP library.

