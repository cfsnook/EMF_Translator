\section{Introduction}
Event-B~\cite{ ABR10} is a formal method that can be used in the rigorous development of software systems. It may be used in by industry for business-, and safety-critical systems; to increase confidence in the correctness of the system~\cite{Russo2009,MetayerC08}. In this paper we focus on the domain of multi-tasking, embedded control systems. Our interest is the application of techniques, and provision of tools, for modelling the systems, and generating code from the models. In previous work~\cite{Edmunds2009, Edmunds2008, ae2010a} we described an intermediate language for generating Java code~\cite{JavaSpec} for multi-tasking implementations, using an object-oriented intermediate specification. During our investigations, we encountered difficulties due to the large semantic gap between Event-B and the intermediate specification language. We also found that models were intractable due to large size of the models. We found that our language introduced too much fine-grained atomicity; which gave rise to a large number of proof obligations.

To address the problems encountered in the previous work, and advance the code generation techniques, we developed a methodology which is more closely integrated with the existing Event-B tools, and approach. In order to achieve a small semantic gap we make just a few additions to the Event-B language. To address the problem of intractably large models we use decomposition~\cite{Butler09a, decomp2010b}. When we are ready to provide implementation details, we use the constructs introduced in the extension (we call it Tasking Event-B) to annotate the development. The annotations and Event-B models are then used to generate code. Tasking Event-B is under-pinned by Event-B operational semantics, so we can also generate a model of the implementation, and show that it is a refinement of the development. We have developed a demonstrator tool~\cite{CGTools} to validate the approach; the tool integrates with the existing Rodin platform~\cite{RodinTool}. We illustrate the approach using a case study with an embedded Heater Controller, and we use of Ada~\cite{ada2005} as the target programming language. Our approach, however, is equally applicable to other programming languages, such as C~\cite{KernighanR88}. 

We continue with section~\ref{motive} in which we discuss our motivation; and section~\ref{OverviewEB} provides an overview of the existing Event-B approach.
Section~\ref{TEB} describes how we model and implement tasks and protected objects. Section~\ref{EnvironModel} describes our approach to generating controller tasks modelling and simulating the environment. 
In Section~\ref{caseStudy} we present a case study. 
Section~\ref{direct} describes how we can read/write directly to memory.
Sections~\ref{flowControl} and~\ref{formalSynch} discuss some theoretical aspects of implementing the model.
Section~\ref{CG} is a brief r\'esum\'e of the code generation step.
Section~\ref{conclude} provides a summary and discussion.

\subsection{Motivation}\label{motive}
The development of the Event-B method, and supporting tools, has been undertaken during the EU DEPLOY~\cite{DEPLOY} project. A number of the industrial partners are interested in the development of multi-tasking, embedded control systems, to which the Event-B method has been applied. The modelling activity is beneficial, leading to a precise definition of the system under development, and shows that various properties of the system hold true as the development proceeds. In order to obtain the full benefit of the Event-B approach, we believe that automatic code generation is useful; so began the work on the final development step, of generating code. The project's industrial partners use a number of programming languages to implement their systems, but we chose one language, Ada~\cite{ada2005}, as a starting point for code generation; primarily because it is a stable, well structured, well-defined language. However, our approach is not limited to Ada, but we consider it to be a good choice because it is typically used in safety-critical systems.  There is also a version called SPARKAda~\cite{SPARKAda}, for high-integrity systems, which is amenable to formal verification. One of our aims is to support compliance with the Ravenscar profile~\cite{Burns1999}. This is in readiness for support, in the future, of the multi-tasking version of SPARKAda, called RavenSPARK~\cite{ravenspark}. Implementations conforming to Ravenscar remove many problems associated with concurrency, and make the development amenable to timing analysis, which is an important consideration in real-time systems.

The work presented here is informed by our previous experience with code generation. Our aim was to find a solution that integrates well with Event-B, having identified Ada as our target language. We have added features that facilitate modelling at the implementation level, and provide the necessary details for code generation. In our current work, we do not formally model all aspects of an implementation, such as timing issues. We do, however, model the behaviour that relates to the control flow; this is specified in a new task body construct, and we provide Event-B semantics - so we generate an additional model of the implementation and show that it refines that abstract development. 

To validate the approach, we developed a case study~\cite{CGTutorial} of a Heating Controller. It is typical of many embedded systems; inputs from the environment are received and processed, and may have some effect in the environment caused by its outputs. We say the inputs to the system are sensed, outputs are actuations. We are interested in modelling sensing and actuating in the environment, and we find it useful to separate the system under development into three distinct partitions. In our approach, we distinguish between three kinds of entities in the implementation - we model controller tasks, environment tasks, and protected objects. The controller tasks interact with the protected objects and environment tasks, but there is no direct communication between controller tasks; this is done via the protected objects.
%
