\section{Conclusions}\label{conclude}
The main focus of the work that we report here is modelling of, and providing implementations for, multi-tasking embedded control systems. We initially model the system using Event-B, but to generate implementations in the coding style that we desire, we have the need for features that do not exist in Event-B. We add various modelling constructs, in an extension to Event-B, that are used to model implementation-level details, including the controller's interaction with the environment. We make use of the extensions to guide code generation. Our contribution is a methodology, and tool support, for facilitating this. We have validated the method and tools using a case study, which provides a basis for future developments in our sphere of interest.

\subsection{discussion}
In our previous work~\cite{Edmunds2009, Edmunds2008, ae2010a}, we found that models quickly became intractable; the models became very large and generated a large number of proof obligations. To address this problem we use the decomposition approach of~\cite{Butler09a, decomp2010b}. After decomposition, the models can be refined further, and when we are ready to provide implementation details, we use the constructs introduced in the extension. The annotations and Event-B models are then used to generate code. In previous work we described an object-oriented intermediate language that we used, to guide code generation. However, we encountered difficulties due to the large semantic gap between Event-B and the intermediate specification language. In the work presented here, the methodology maintains a small semantic gap, we achieve this by adding only a minimal number of constructs to the Event-B language. The implementation of a machine, for instance, can be either a controller task, environment task, or protected object. We apply a single annotation to the machine, which describes the implementation. In the case of the tasks, we add a task body annotation describing the event ordering; which includes branching and iteration constructs. Individual events can map to a number  programming constructs; their implementation is defined by their use in the task body, and by any additional annotations. 

The work presented here, also includes a solution for modelling low-level interaction with the environment; that is, sensing and actuating. We take into consideration that, in the final deployable system, inter-task communication is prohibited. The main driver for this restriction is that we wish to generate safe multi-tasking code which is compliant with the Ravenscar subset of Ada~\cite{ravenspark}. However, we are able to relax this restriction for environment tasks, since our primary task is to simulate the environment. The sensing and actuating events give rise to two styles of implementation: one using entry calls, and one using addressed variables. In the entry-call style, calls are a way of updating sensed variables in a controller task, and controlled variables in the environment task. The entry is implemented in the environment, and called from the controller task. In the Ada translator we generate entries in the environment task specification, and these are implemented by \textbf{accept} clauses in the task body. We may find, in future work, that this approach has a role to play when implementing the interaction between tasks and external driver APIs. The second style, addressed variables, associates address information with each of the parameters of a controller task's sensing or actuating events.  In our case study, a parameter with address and base, is translated to a variable which is declared using Ada representation address clauses. Other languages, like C, would reference the address using a pointer. When the variable is used in an expression, the specified memory address is read from, or written to.

The case study of Section~\ref{caseStudy} was proposed in the course our Deploy project~\cite{DEPLOY}. The models arising from this activity are available at~\cite{aeHeatingControllerArch}, and form part of a tutorial available at~\cite{CGTutorial}. It is here that one can find a listing of all the generated code. The contribution made in this paper is a general solution, to a particular problem highlighted by the initial work on the case study. Namely, that the restriction on inter-task communication forced us to adopt a particular modelling style, and this did not reflect the way that systems are implemented in industry. We removed the restriction on inter-task communication, making the the environment machine a special case. We introduced new event annotations, sensing and actuating; and a new parameter annotation, addressed variables. These new features use the existing synchronization approach, arising from model decomposition, to model interaction with the environment. The annotations guide the translator to produce the appropriate code.


The case study was used as to validate the approach. We have shown that it is possible to use Tasking Event-B to model a system, and its environment, in such a way that leads to generated code of use to industry. The annotations facilitate automatic generation of deployable controller code, and a simulation of the environment. The partitioning of the tasks in the controller and the environment, using Event-B decomposition, is quite intuitive. The semantics of event synchronization allow us to model the interaction between the decomposed tasks of the controller and environment. 

There are a number of avenues that may be explored in future work. For instance multiple Environ machines could be used; that is one machine for each device in the environment. The task entries may provide the basis for a link with device driver APIs. It would also be useful to explore interaction with a modelling tool such as Simulink.
%
\subsection{Related Work}
The closest comparable work is that of Classical-B's code generation approach~\cite{TheBBook} using B0~\cite{B0RefMan}. B0 consists of concrete programming constructs, these map to programming constructs in target programming languages. B0 can be translated to Ada, but there is no support for concurrency. The Event-B and Classical-B approaches differ in many respects. For example, the Event-B approach supports modelling of the controller, and environment together; Classical-B is aimed more at modelling software systems in a modular fashion, and the generated code is sequential, and does not consider concurrency. In the work presented here, we have added the ability to provide an Ada implementation of the deployable code, and an environment simulation. Code generation of B to embedded systems was carried out in~\cite{BertBPRV03}, where the implementation results in sequential code. Some consideration is given, in~\cite{StoddartCZ07}, to the use of an Event-B-like syntax for analysis of multi-tasking programs. In comparison, we use the task body for scheduling, rather than taking a purely interrupt driven approach; we have yet to incorporate modelling of interrupts in Tasking Event-B.

VDM++~\cite{CSK_LANG_MAN} may be used to generate code, it is an object-oriented extension to VDM-SL formal specification language. It has been used to model real-time systems, see~\cite{VerhoefLH06}. The paper describes a controller and environment model similar to our own. They go on to define an abstract operational semantics, which is quite general, and has additional features when compared to our work. They model time, and asynchronous communication. We do not address these issues in our work since the research is ongoing. 

Scade~\cite{Berry07} is an industrial tool for formally modelling embedded systems. It provides a graphical approach to specification, and has a certified code generator. It has a similar control flow approach to that of UML-B statemachines~\cite{SnookB08}. However, we have not investigated code generation from UML-B to Ada. 

In~\cite{KarsaiSLB03} Karsai et al. describe some common elements of modelling approaches for embedded software development. The work that we present here is comparable in some ways, since we can view our approach as an example of the Model-Integrated Computing~\cite{NeemaK04} that they describe. Their approach suggests development is based on models and generation, which ours is; and that the approaches have multiple views which ours has (for example UML-B~\cite{SnookB08}). They also advocate an extensible approach: the Rodin tool has a built-in extension mechanism, and our tools are based on a extensible meta-models. The approach differs in that they focus on hardware architecture and signal-flow aspects of the design, and use a Finite State Automata~\cite{Henzinger96} approach to formalize the dynamic aspects of the system. Event-B is a state-based approach, but does have analysis such as ProB~\cite{ProB} to address dynamic aspects.
