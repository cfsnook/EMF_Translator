\section{An Overview of Event-B}\label{OverviewEB}
The Event-B method~\cite{ ABR10} is a descendant of the classical B-Method~\cite{TheBBook}, and less directly, Z~\cite{Spivey89}. It is a set-theoretic approach to modelling discrete systems, using predicate logic, first order logic, and refinement. The motivation for developing Event-B, from the existing B-Method, was to simplify the task of modelling and proof, and increase the use of automation~\cite{Hallerstede07}. An Event-B development consists of a project containing contexts and machines. Contexts are used to describe the static aspects of a system. Sets and constants are specified, and axioms describe the relationships between them. The dynamic aspects of a system are specified in machines. Machines are able to \emph{see} contexts, so that the contents of a context is visible, and can be used within the machine. Variables keep track of the values, and guarded events update state. The properties of the system are specified in the invariants clause. The invariants of a machine give rise to proof obligations, which are generated automatically by the tool. A large number of these proof obligations can be discharged quickly, by automatic proof tools. Where the automatic provers fail, the user has the opportunity to guide the proof interactively. The proof activity can proceed, with the user suggesting strategies to complete the proof. 
%
\subsection{An Event-B Model}
A fragment of an Event-B specification is shown in Fig.~\ref{fig:TextualEventB}.
%
\begin{figure}
\begin{sffamily}
\begin{minipage}{0.5\linewidth}
%\begin{center}
\begin{tabular}{l}
\textbf{machine} HCtrl\_M1 \\
\textbf{sees} HC\_CONTEXT  \\
\textbf{refines} HCtrl\_M0  \\
\textbf{variables}  cttm cttm2 \ldots \\
\textbf{invariants}\\
\quad  cttm $\in \intg$\\ 
\quad  cttm2 $\in \intg$\\
\qquad  \ldots
\end{tabular}
\end{minipage}
\begin{minipage}{0.5\linewidth}
\begin{tabular}{l}
\quad\textbf{event} Get\_Target\_Temperature2\\
\quad\textbf{any} tm\\
\quad\textbf{where}\\
\qquad  tm $\in \intg$\\ 
\qquad tm = cttm\\
\quad\textbf{then}\\
\qquad cttm2 $\bcmeq$ tm\\
 \quad \textbf{end}
\end{tabular}
\end{minipage}
\end{sffamily}
%\end{center}
	\caption{Example of Textual Event-B}
	\label{fig:TextualEventB}
\end{figure}
%
The specification has a number of variable declarations, which are typed in the \textbf{invariants} clause. Additional predicates are added to the invariants clause to describe the desired safety properties. The machine invariant is a conjunction of the list of predicates in the invariants clause. The \emph{Get\_Target\_Temperature2} event declares one parameter \emph{tm} in the \textbf{any} clause. The \textbf{where} clause contains the event guards, the first clause is a typing predicate for \emph{tm}. The second constrains the value that \emph{tm} can take. The guards describe enabling conditions for an event. Each clause is a predicate over the sets, constants, and variables of the system. All of the guard clauses must be true for an event to be enabled. If an event is enabled, the updates in its action may occur if the event is selected by the environment. Event actions are defined in the \textbf{then} clause; they consist of assignments to machine variables; the assignment may be simple, or non-deterministic. The clause in the example consists of a single, simple assignment, where the variable \emph{cttm2} is assigned the value of the parameter~\emph{tm}.  
\subsection{Machine Decomposition and Event Synchronization}\label{synchDecomp}
Decomposition is a technique that is commonly used to handle complexity. There are currently two styles of composition that can be used with Event-B. They are the shared variable~\cite{AbrialH07}, and shared event~\cite{Butler09a}, styles. In our approach, we make use of shared event decomposition. During the decomposition process, we decide where the machine variables will reside in the decomposed model. In the example of Fig.~\ref{fig:TextualEventB} we put \emph{cttm2} in one machine, and \emph{cttm} in another. Decomposition gives rise to two machines; each with an event called \emph{Get\_Target\_Temperature2}. The event guards and actions will differ though, so it is not just a simple copy. Events can be recomposed following decomposition, to restore the original structure. It can be shown that the recomposed machines refine the original abstract machine, and recomposed events refine their abstract counterparts. The pairs of events, arising from decomposition, are said to synchronize~\cite{Butler2006}. The implementation of synchronized events maps naturally to an atomic subroutine, and we use this in our translation to code.
