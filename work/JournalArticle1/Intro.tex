\section{Introduction}
Event-B~\cite{ABR10} is one of a number of formal methods that may be used to model systems where a high degree of reliability is required. Event-B was inspired by its predecessor, \emph{Classical-B}~\cite{TheBBook}. It is a modelling language, used with a supporting tool platform, Rodin~\cite{abrial10rodin}; so named from the project in which it was developed~\cite{RodinTool}.  

In this section we introduce Event-B to the reader, and compare Event-B with some other formal approaches. We discuss automatic code generation from formal models, and potential target programming languages.

In Sect.~\ref{} we...
In Sect.~\ref{} we...

\subsection{An Event-B Overview}
The formal methods related to the work presented here can be categorized as state-based formal methods. Alternative, but not unrelated, approaches are categorized as process-based methods. Classical-B~\cite{TheBBook,CNP,CNPInterface,B4Free} and its successor, Event-B are said to be state-based, since they focus on modelling the changes of state, not the behaviour of processes. In Classical-B, state updates are modelled by guarded operations, where the operation is an analogue of a procedure call in a programming language.

\subsubsection{Event-B Introduction}
 In Event-B, state updates are modelled by guarded events, providing a more abstract view of the way a system evolves. Event-B can be used to model systems at an abstract level; and by adding more detail (using a technique called refinement) it can model the software aspects of systems too. Both methods are set theoretic modelling approaches that incorporate a notion of proof to show that important system properties are maintained. The former is primarily an approach to software systems development, the latter more widely applicable to system-modelling. In an effort to make modelling and proof easier, Event-B was developed to overcome some of the difficulties encountered when using in Classical-B. The main differences between Classical and Event-B are highlighted in~\cite{Hallerstede07}, and inspiration was also drawn from action systems~\cite{Back1990133}.

It is fair to say that Event-B is not just a formal modelling language; the name is used to describe both a notation, and a methodology. In addition to this a mature tool-platform called \emph{Rodin}, named after its development programme, complements the methodology. The main modelling components of Event-B are contexts and machines. Contexts are used to model static features using sets, constants, axioms, and theorems. Machines are used to model variable state using \emph{variables}. A third, more recent addition, is the Theory component; where a developer can augment the bundled mathematical language, and rule-base, with new (inference and re-write) rules, data types, and operators. During the modelling process, changes to the components result in automatic generation of proof obligations, which must be discharged in order to show that the development is consistent. The proof obligations generated in classical-B are often complex, the Event-B approach results in simpler proof obligations as described in~\cite{Hallerstede07}, since Event-B consists of a simplified action syntax, giving rise to simpler proof obligations. A further simplification was made by adopting an event-based approach, where each atomic event has a predicate guard and an action consisting only of assignment statements. Events correspond to operations in the B-method; operation specification was more expressive, and included constructs for specifying operation preconditions (as part of its Design by Contract approach), operation calls, return parameters, and more complex structures for branching and looping. These constructs are not features of Event-B. Due to these simplifications (and more efficient proof tools) a large number of the proof obligations may be discharged automatically, by the automatic provers. Where un-discharged proof obligations remain, the user has, at their disposal, an interactive prover. Various techniques can be applied, to discharge the proof obligations, such as adding hypotheses; or making use of the hyperlink-driven user interface, for rule and tactic application. In the early stages of development with Event-B, a developer will begin by abstracting, and modelling, the observable events occurring in a system. Event-B, as the name suggests, takes an event-based view of a system; where events occur spontaneously from the choice of enabled events. An event is said to be enabled when the guard is true, and the state updates, described in the event actions, can take place; otherwise it is disabled, and none of its updates can occur.  

\subsubsection{An Event-B Example}
An example of an Event-B machine can be seen in Fig.~\ref{fig:controllerSpec2}. It shows an abstract model of a pump controller, used in one of the case studies. We will use this model to describe some features of Event-B. But first we introduce the case study, which models a discrete \emph{pumpController}. The model describes a system where the controller receives a value of the fluid level, and a boolean value representing a user-request to turn the pump. Based on the inputs to the controller, a command to turn the pump on may be issued, or a warning is issued if a minimum level \emph{MIN} has been reached.    
%
%
%
\begin{figure}[h]
\centering
\begin{minipage}{0.8\textwidth}
\textcolor{blue}{MACHINE} m1 \textcolor{blue}{REFINES} m0 \textcolor{blue}{SEES} ctx \\
\textcolor{blue}{VARIABLES} \text{m\_level, c\_level, e\_level, m\_pumpOnReq, c\_pumpOnReq, e\_pumpOnReq,} \hspace*{0.2cm} m\_pumpOnCmd, c\_pumpOnCmd, e\_pumpOnCmd, m\_warn, c\_warn, e\_warn,\\
\hspace*{0.2cm} c\_level\_internal, c\_pumpOnReq\_internal\\
\textcolor{blue}{INVARIANTS}\\
\hspace*{0.2cm}(c\_level\_internal $\leq$ MIN $\land$  c\_pumpOnReq\_internal = TRUE $\limp$  c\_warn = TRUE)\\
\hspace*{0.2cm} $\land$ (c\_level\_internal $>$  MIN $\land$  c\_pumpOnReq\_internal = TRUE\\
\hspace*{0.5cm} $\limp$  c\_pumpOnCmd = TRUE)\\
\hspace*{0.2cm} $\land$ (c\_level\_internal $\in  \intg$)\\
\hspace*{0.2cm} $\land$ (c\_pumpOnReq\_internal $\in$  BOOL) \ldots\\
\textcolor{blue}{EVENTS}\\
\textcolor{blue}{INITIALISATION} c\_level :=  100 $\pprod$ m\_level := 80 $\pprod$ c\_pumpOnReq :=  FALSE $\pprod$ \ldots\\
\textcolor{blue}{EVENT} fmiSetBoolean\_c \textcolor{blue}{REFINES} fmiSetBoolean\_c\\
\hspace*{0.2cm}\textcolor{blue}{ANY} p\\
\hspace*{0.2cm}\textcolor{blue}{WHERE} p = c\_compound $\land$ p $\in$ BOOL  \\
\hspace*{0.2cm}\textcolor{blue}{THEN} m\_pumpOnCmd :=  p\\
\hspace*{0.2cm}\textcolor{blue}{END}\\
\ldots
\end{minipage}
\caption{An Event-B  Pump Controller Model}
\label{fig:controllerSpec2}
\end{figure}
%
%
%
\begin{figure}[b]
\centering
\begin{minipage}{0.3\textwidth}
\textcolor{blue}{CONTEXT} ctx  \\
\textcolor{blue}{CONSTANTS} MIN\\
\textcolor{blue}{AXIOMS} MIN = 10
\end{minipage}
\caption{An Example Context}
\label{fig:context}
\end{figure}
%
%
 In Fig.~\ref{fig:controllerSpec2}, we see that machine \emph{M1} refines another machine \emph{M0}; we will discuss refinement in Subsect.~\ref{ref}. It also has a \emph{SEES} clause; this makes the contents of a context visible to a machine. Contexts may contain sets, constants, axioms and theorems, and example context can be seen in Fig.~\ref{fig:context}. There are variables representing the internal state of the controller, and invariants providing type information for variables. Invariants are also used to describe the safety properties of the system. This describes a required safety property, that if the level is at or below \emph{MIN}, and a user's pump-on request is detected, then a warning will be issued. Also, if the level is OK and a pump-on is requested, then the state \emph{pumpOnCmd = TRUE} is  set.  Following the \emph{INVARIANTS} clause are the model's \emph{Events}. The \emph{Initialisation} event is special event, since it has no guards. The initialisation event of a machine must occur before any other event in the machine is enabled. The event in the figure has a parameter \emph{p}, in the \emph{ANY} clause. Parameters can be used to represent information flow, in and out of events, or they can represent a \emph{local} variable within the scope of the event. The event guard is defined in the \emph{WHERE} clause, in the example, where \emph{p} is typed as a Boolean. The guard relates the parameter to a machine variable \emph{c\_pumpOnCmd}, in the predicate $ p = c\_compound$. The event action appears in the \emph{THEN} clause, where the parameter is assigned to the variable \emph{m\_pumpOnCmd}, in the expression $m\_pumpOnCmd := p$.


\subsubsection{Refinement and Extension}\label{ref}
As we mentioned earlier in the section, Event-B makes use of a technique called refinement, where a machine can be refined by another. The counterpart to refinement of machines, is extension of contexts. This allows a user to build upon pre-existing contexts using the \emph{EXTENDS} clause, by adding more sets, constants, axioms and theorems. When a machine imports a context, the contexts that it extends are accessible to the machine also. In a refinement, new variables, events and invariant properties can be added; or existing events can be modified, but in a restricted manner. Machine refinement is transitive and leads to a hierarchical structure. Refinements are related to their more abstract counterparts in such a way that, a valid refinement always satisfies the specifications higher in the refinement hierarchy. In this way, important system properties can be specified at a high level of abstraction, and maintained down through the refinement chain. The Event-B tools are responsible for generating the proof obligations relating to refinement; these must be discharged in a similar way to those generated for proof of machine consistency. It is often necessary to specify a linking invariant, to describe the relationship between the variables of the abstract and refinement machines. Inspection of the proof obligations can assist in this task since some of the un-discharged proof obligations provide information about this link. In some cases we may model entities in an abstraction that are defined in the event parameters; and in the refinement these entities may be introduced to the model as machine variables. To assist with the proof effort we have a slightly different strategy to that of refining abstract variables with concrete variables. We link the parameters of the abstract event, with their concrete counterpart, using a $WITNESS$. This construct is a predicate describing the relationship between an event parameter (that disappears) from an abstract model, and the corresponding (refining) variable in the concrete model. Another feature of Event-B is the ability to  refine one atomic event with a number of events, thus breaking the atomicity, as described in~\cite{Butler08}. Eventually, at the end of a refinement chain the models are detailed enough to accurately describe an implementation. But Event-B is a modelling language, and there is a disjunction between the description of the system in Event-B, and commonly used programming languages, such as Java, C and Ada. Addressing the semantic gap between Event-B and programming constructs is the subject of this article, which we will introduce fully, later in the article. 
%
%
%
\subsection{Related Approaches}
To make the most of the formal modelling approach, it is desirable to use the existing formal modelling artefacts to generate implementations for, at least, some parts of the system being modelled. The Classical-B~\cite{TheBBook} approach made use of an implementation-level notation called \emph{B0}, described in~\cite{B0RefMan}. B0 is similar to a programming language, and consists only of concrete programming constructs. These constructs map to programming constructs in a number of programming languages. \emph{B0} forms part of the Classical-B refinement chain, so the implementation-level specification refines the abstract development. Translators are available targeting programming languages such as Ada~\cite{ada2005} and C~\cite{KernighanR88}.

 Our OCB implementation notation exists at a similar level to B0 in the refinement chain, between the formal model and implementation; and similarly the constructs we chose for OCB have convenient mapping to constructs in our target domain - that of object-oriented programs. It should be noted though whilst B0 can be translated to the C++ programming language~\cite{stroustrup2000} there is no support for concurrent processing of threads; and the main factor for choosing Java in our work was its good support in this respect. Other target languages of the B0 translators are C~\cite{KernighanR88}, and $High~ Integrity~ Ada$ (based on $SPARKAda$~\cite{SPARKAda}). $SPARKAda$ is a target programming language that we could consider translating to in future work since it incorporates proof of program consistency using a Design-by-Contract approach.

%CSP || B 
In the early stages of our investigations we considered using a combined CSP and B approach to specify the order in which the atomic actions may occur, and to specify points at which the actions of processes may interleave. In such a development the specifications are combined so that the B operations synchronize with the corresponding CSP events with the same name. We considered this approach to be more complex than the approach we ultimately adopted, and introduced the sequence operator and labels for atomic clauses, to OCB. The sequence operator, together with the labels (mapped to program counters in Event-B), perform the same role as the CSP specification by imposing an ordering on the events. Additional considerations in making this choice, at the time, were the lack of tool support for combined Event-B and CSP, and the potential overlap with the work on JCSProB~\cite{YangPop2007} that we discuss later.  The combined CSP and B approach, $CSP\pprod B$, ~\cite{SchneiderT02, SchneiderT05} continues to be of interest to researchers. 

Other work with CSP, related to our approach, is JCSP~\cite{JCSPMulti, JCSPNet} and JCSProB~\cite{YangPop2007}. JCSP links the OCCAM~\cite{STMoccam} subset of the CSP process algebra and the Java programming language. The result is the ability to specify process behaviour in CSP, and translate to Java. The resulting Java is a message passing style implementation of communication between processes. This differs from the shared memory approach described in our work. JCSProB combines the CSP and classical-B formal methods, the $ProB$ tool can be used to provide a unified approach for specification and model checking. The most obvious difference between the $JCSProB$ approach and OCB, once again, is that our work is aimed at the more recent Event-B approach. $JCSProB$ uses the CSP prefix operator to provide an ordering on the events that occur, with the operations of the B machine synchronizing with the CSP events. A CSP process may specify events that are not shared with other processes, this allows processes events to interleave - restricted only by the ordering imposed by the sequence operator (since the processes do not synchronize on common events). In OCB we can specify when interleaving may occur at certain points in non-atomic constructs, such as at the end of each while loop iteration. We also order the executions of labelled atomic clauses, using a sequential operator. The sequence operator is used in a process class' $run$ operation to define an ordering of executions and to define points where other processes may interleave. In both $JCSProB$ and OCB the specifications are translated to threads which can run concurrently, and perform state updates. 

Other work involving CSP is that of $Circus$~\cite{WoodcockC01}, which is a combined approach using CSP and $Z-notation$~\cite{Spivey89}. In a $Circus$ specification the $Z$ and CSP constructs are used to build a specification that is amenable to model checking using~\cite{WoodcockCF05}. In this respect $Circus$ has more in common with $JCSProB$ than OCB since it is a combined approach using model-checking technology, OCB is not a combined approach. $Circus$ can be translated to Java as described in~\cite{FreitasC06}, making use of the JCSP library code.

The OCB approach we advocate has a strong object-oriented bias, which is in part due to our choice of target implementation. In addition though, the use of an object-oriented specification style in OCB has many benefits; such as the use of classes as templates for instantiating multiple objects and encapsulating data. The benefits of object-oriented techniques have been applied to a number of formal approaches, one such approach involving object-oriented technology and Event-B, is that of UML-B. UML-B is a graphical front-end for Classical-B and Event-B and provides facilities to model a wide range of developments diagrammatically using class and statechart diagrams. We gained insight into the modelling of classes, objects, and ordering of events from UML-B; however there is no facility to translate the model to an implementation. The additional information contained in the $ProcessClass$ and $MonitorClass$ specifications of OCB, provide the necessary information to facilitate the translation to an object-oriented implementation. Due to the similarity of approaches it therefore possible that some UML-B developments will be intuitively refined by OCB specifications; in particular this would be quite apparent if a graphical front-end, similar to UML-B, were created for OCB. 

There have been other approaches involving formal methods and object oriented technology. VDM++ is an object-oriented extension to VDM-SL formal specification language. Models can be described textually; or using a graphical interface using UML diagrams, in much the same way as UML-B does for B and Event-B. VDM++ can be used with the VDM++ Toolbox to generate C++ and Java code. VDM++ can be used to model and implement developments with concurrently executing processes, using threads. Conditional waiting can be specified using permission predicates, in a similar way to the OCB \textbf{when} construct. Another approach that is derived from VDM and additionally CSP is the RAISE Method~\cite{Raise99}. The RAISE Method describes how formal development may be undertaken in a number of different ways. There are guidelines for applicative (functional) and imperative specification styles, for both sequential and concurrent systems. The approach covers the development activity from requirements specification through to translation, which is most relevant for this discussion. The RAISE method uses a specification notation called the RAISE Specification Language (RSL). A developer may initially make use of the language's high level specification constructs, that involve non-determinism, and may use a step-wise refinement approach to move towards implementation. RSL also contains the low level implementation constructs used at this level - unlike OCB in which we distinguish Event-B from OCB. The implementation level specification can then be translated into a traditional programming language, due to the similarity of the low level RSL constructs and traditional programming constructs. Following this the resulting code is compiled into executable, or interpreted code, in a similar way to the OCB approach. As with OCB the RAISE approach recognises the difficulty of formally linking the executable code and the related abstract specifications.

$Object-Z$~\cite{GSmith2000} is an object-oriented approach to development using $Z$. Unlike the work presented in the thesis, the Object-Z approach allows the use of inheritance and polymorphism in specifications. In Object-Z operations are blocked if the pre-condition is not true, which is similar to the OCB conditional waiting construct. A route to implementation is described using a translation to $PerfectDeveloper$~\cite{PD} in~\cite{Stevens06}. $PerfectDeveloper$'s approach is to use verified-Design By Contract, where verification conditions are generated from a specification using constructs such as pre and postconditions, class and loop invariants, and assertions. The verification conditions must be shown to hold in order to show the specified contracts are satisfied by the implementation. They are generated for each method entry to show that the precondition holds, for each method exit to show that the postcondition holds, and wherever an assertion appears. $PerfectDeveloper$ provides automatic, and semi-automatic, translations to Java and C++ but appears not to support concurrent processing. In future work we will consider linking OCB to a verifiable implementation language such as $SPARKAda$, here concurrency may be facilitated using the $RavenSPARK$ version. Another approach would be to investigate the use of JML~\cite{draftJML} annotations to specify a contract which we should ensure is satisfied.

\subsection{Code Generation Rationale}


\subsection{Targets for Code Generation}

- Ada

- Java

- FMI-C
